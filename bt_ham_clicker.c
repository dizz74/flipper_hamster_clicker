#include "bt_ham_clicker.h"

#include <stdint.h>
#include <furi.h>
#include <furi_hal_bt.h>
#include <furi_hal_usb_hid.h>
#include <extra_profiles/hid_profile.h>
#include <bt/bt_service/bt.h>
#include <gui/gui.h>
#include <gui/icon_i.h>
#include <notification/notification.h>
#include <notification/notification_messages.h>
#include <storage/storage.h>

#define BTN_EVT_QUEUE_SIZE 512
#define CLICK_DELAY 5
#define MOUSE_MOVE 100
#define BT_MOUSE_FLAG_INPUT_EVENT (1UL << 0)
#define BT_MOUSE_FLAG_KILL_THREAD (1UL << 1)
#define BT_MOUSE_FLAG_ALL (BT_MOUSE_FLAG_INPUT_EVENT | BT_MOUSE_FLAG_KILL_THREAD)
#define HID_BT_KEYS_STORAGE_NAME ".bt_hid.keys"

typedef struct BTInputEvent {
    int8_t button;
    int8_t dx;
    int8_t dy;
} BTInputEvent;

const uint8_t _ic_ham0_0[] = {
    0x00, 0x00, 0xe6, 0x9f, 0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x80,
    0x1d, 0xe0, 0x06, 0x00, 0x00, 0x00, 0x80, 0x07, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x0e, 0x00,
    0x00, 0x00, 0x60, 0x10, 0x20, 0x38, 0x00, 0x00, 0x00, 0x18, 0x10, 0x20, 0x60, 0x00, 0x00, 0x00,
    0x0c, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x0c, 0x80, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x04, 0xc0,
    0x0c, 0x80, 0x00, 0x00, 0x00, 0x04, 0x80, 0x04, 0x80, 0x00, 0x00, 0x00, 0x06, 0x80, 0x07, 0x80,
    0x01, 0x00, 0x00, 0x06, 0x00, 0x03, 0x80, 0x01, 0x00, 0x00, 0x04, 0x00, 0x03, 0x80, 0x00, 0x00,
    0x00, 0x8c, 0x03, 0x00, 0xc7, 0x00, 0x00, 0x00, 0x0c, 0x1e, 0xe0, 0xc1, 0x00, 0x00, 0x00, 0x18,
    0xf8, 0x7f, 0x60, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00,
    0x1c, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x80, 0x1f, 0x00, 0x00, 0x00, 0x20, 0xfe, 0xff, 0x31, 0x00,
    0x00, 0x00, 0x30, 0xe2, 0x1f, 0x31, 0x00, 0x00, 0x00, 0x10, 0x02, 0x00, 0x21, 0x00, 0x00, 0x00,
    0xd8, 0x7f, 0xf8, 0x6f, 0x00, 0x00, 0x00, 0xc8, 0x43, 0x08, 0x4f, 0x00, 0x00, 0x00, 0x0c, 0x60,
    0x18, 0xc0, 0x00, 0x00, 0x00, 0x04, 0x30, 0x30, 0x80, 0x00, 0x00, 0x00, 0x06, 0x1c, 0xe0, 0x80,
    0x01, 0x00, 0x00, 0x06, 0x0f, 0xc0, 0x87, 0x01, 0x00, 0x00, 0x02, 0x03, 0x00, 0x03, 0x01, 0x00,
    0x00, 0x02, 0x06, 0x80, 0x01, 0x01, 0x00, 0x00, 0x03, 0x06, 0x80, 0x01, 0x03, 0x00, 0x00, 0x03,
    0x0c, 0xc0, 0x00, 0x03, 0x00, 0x00, 0x03, 0x18, 0x60, 0x00, 0x03, 0x00, 0x00, 0x03, 0x38, 0x70,
    0x00, 0x03, 0x00, 0x00, 0x03, 0xe0, 0x1f, 0x00, 0x03, 0x00, 0x00, 0x03, 0xc0, 0x0f, 0x00, 0x03,
    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x0c, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x0c, 0xe0,
    0x1f, 0xc0, 0x00, 0x00, 0x00, 0x1e, 0x78, 0x78, 0xe0, 0x03, 0x00, 0x00, 0x93, 0x0f, 0xc0, 0x27,
    0x03, 0x00, 0x80, 0x81, 0x07, 0x80, 0x07, 0x06, 0x00, 0x00, 0x03, 0x06, 0x80, 0x01, 0x03, 0x00,
    0x00, 0xde, 0x03, 0x00, 0xef, 0x01, 0x00, 0x00, 0xfc, 0x01, 0x00, 0xfc, 0x00, 0x00};
const uint8_t* const _ic_ham0[] = {_ic_ham0_0};
const Icon ic_ham0 =
    {.width = 50, .height = 50, .frame_count = 1, .frame_rate = 0, .frames = _ic_ham0};

const uint8_t _ic_ham1_1[] = {
    0x00, 0x00, 0xe6, 0x9f, 0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x80,
    0x1d, 0xe0, 0x06, 0x00, 0x00, 0x00, 0x80, 0x07, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x0e, 0x00,
    0x00, 0x00, 0x60, 0x10, 0x20, 0x38, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x20, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x08, 0x80, 0x07, 0x40, 0x00, 0x00, 0x00, 0x08, 0xc0,
    0x0c, 0x40, 0x00, 0x00, 0x00, 0x0c, 0x80, 0x04, 0xc0, 0x00, 0x00, 0x00, 0x04, 0x80, 0x07, 0x80,
    0x00, 0x00, 0x00, 0x0c, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x08, 0x00, 0x03, 0x40, 0x00, 0x00,
    0x00, 0x08, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x08, 0xc0, 0x0f, 0x40, 0x00, 0x00, 0x00, 0x10,
    0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00,
    0x1c, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x80, 0x1f, 0x00, 0x00, 0x00, 0x20, 0xfe, 0xff, 0x31, 0x00,
    0x00, 0x00, 0x30, 0xe2, 0x1f, 0x31, 0x00, 0x00, 0x00, 0x10, 0x02, 0x00, 0x21, 0x00, 0x00, 0x00,
    0xd8, 0x7f, 0xf8, 0x6f, 0x00, 0x00, 0x00, 0xc8, 0x43, 0x08, 0x4f, 0x00, 0x00, 0x00, 0x0c, 0x60,
    0x18, 0xc0, 0x00, 0x00, 0x00, 0x04, 0x30, 0x30, 0x80, 0x00, 0x00, 0x00, 0x06, 0x1c, 0xe0, 0x80,
    0x01, 0x00, 0x00, 0x06, 0x0f, 0xc0, 0x87, 0x01, 0x00, 0x00, 0x02, 0x03, 0x00, 0x03, 0x01, 0x00,
    0x00, 0x02, 0x06, 0x80, 0x01, 0x01, 0x00, 0x00, 0x03, 0x06, 0x80, 0x01, 0x03, 0x00, 0x00, 0x03,
    0x0c, 0xc0, 0x00, 0x03, 0x00, 0x00, 0x03, 0x18, 0x60, 0x00, 0x03, 0x00, 0x00, 0x03, 0x38, 0x70,
    0x00, 0x03, 0x00, 0x00, 0x03, 0xe0, 0x1f, 0x00, 0x03, 0x00, 0x00, 0x03, 0xc0, 0x0f, 0x00, 0x03,
    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x0c, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x0c, 0xe0,
    0x1f, 0xc0, 0x00, 0x00, 0x00, 0x1e, 0x78, 0x78, 0xe0, 0x03, 0x00, 0x00, 0x93, 0x0f, 0xc0, 0x27,
    0x03, 0x00, 0x80, 0x81, 0x07, 0x80, 0x07, 0x06, 0x00, 0x00, 0x03, 0x06, 0x80, 0x01, 0x03, 0x00,
    0x00, 0xde, 0x03, 0x00, 0xef, 0x01, 0x00, 0x00, 0xfc, 0x01, 0x00, 0xfc, 0x00, 0x00};
const uint8_t* const _ic_ham1[] = {_ic_ham1_1};
const Icon ic_ham1 =
    {.width = 50, .height = 50, .frame_count = 1, .frame_rate = 0, .frames = _ic_ham1};

typedef struct BtApp {
    FuriHalBleProfileBase* hid;
    ViewPort* view_port;
    Bt* bt;
    NotificationApp* notifications;
    FuriMutex* mutex;
    FuriThread* thread;
    bool connected;
    bool clicking;
    int qhead;
    int qtail;
    BTInputEvent queue[BTN_EVT_QUEUE_SIZE];
} BtApp;

const BleProfileHidParams ble_hid_params = {
    .device_name_prefix = "HAMToucher",
    .mac_xor = 0x0001,
};

void btApp_draw_callback(Canvas* canvas, void* context) {
    furi_assert(context);
    BtApp* btapp = context;

    canvas_clear(canvas);
    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str(canvas, 0, 10, "BT Hamster eater =)");
    canvas_set_font(canvas, FontSecondary);

    if(!btapp->connected) {
        canvas_draw_str(canvas, 0, 20, "Disconnected");
        canvas_draw_str(canvas, 0, 30, "Search HAMToucher");
        canvas_draw_icon(canvas, 90, 13, &ic_ham1);
    } else {
        if(btapp->clicking) {
            canvas_draw_str(canvas, 0, 20, "Eating...");            
            canvas_draw_icon(canvas, 90, 13, &ic_ham0);
        } else {
            canvas_draw_str(canvas, 0, 20, "Press OK to eat");
            canvas_draw_icon(canvas, 90, 13, &ic_ham1);
        }
    }
}

void btApp_queue_input(BtApp* btApp, BTInputEvent event) {
    furi_mutex_acquire(btApp->mutex, FuriWaitForever);
    btApp->queue[btApp->qtail++] = event;
    btApp->qtail %= BTN_EVT_QUEUE_SIZE;
    furi_mutex_release(btApp->mutex);

    FuriThreadId thread_id = furi_thread_get_id(btApp->thread);
    furi_assert(thread_id);
    furi_thread_flags_set(thread_id, BT_MOUSE_FLAG_INPUT_EVENT);
}
void btApp_button(BtApp* btApp, int8_t button) {
    if(btApp->connected) {
        BTInputEvent event;
        event.button = button;
        event.dx = 0;
        event.dy = 0;
        btApp_queue_input(btApp, event);
    }
}

void btApp_move(BtApp* btApp, int8_t dx, int8_t dy) {
    if(btApp->connected) {
        BTInputEvent event;
        event.dx = dx;
        event.dy = dy;
        btApp_queue_input(btApp, event);
    }
}

int32_t btApp_thread_callback(void* context) {
    furi_assert(context);
    BtApp* btApp = (BtApp*)context;

    while(1) {
        uint32_t flags =
            furi_thread_flags_wait(BT_MOUSE_FLAG_ALL, FuriFlagWaitAny, FuriWaitForever);
        if(flags & BT_MOUSE_FLAG_KILL_THREAD) {
            break;
        }
        if(flags & BT_MOUSE_FLAG_INPUT_EVENT) {
            furi_mutex_acquire(btApp->mutex, FuriWaitForever);
            BTInputEvent event;
            bool send_buttons = false;
            if(btApp->qhead != btApp->qtail) {
                event = btApp->queue[btApp->qhead++];
                btApp->qhead %= BTN_EVT_QUEUE_SIZE;
                send_buttons = true;
            }
            furi_mutex_release(btApp->mutex);

            if(btApp->connected && send_buttons) {
                if(event.dx != 0 || event.dy != 0) {
                    ble_profile_hid_mouse_move(btApp->hid, event.dx, event.dy);
                } else {
                    ble_profile_hid_mouse_press(btApp->hid, event.button);
                    furi_delay_ms(CLICK_DELAY);
                    ble_profile_hid_mouse_release(btApp->hid, event.button);
                }
            }
        }
    }

    return 0;
}

void btApp_thread_start(BtApp* btApp) {
    furi_assert(btApp);
    btApp->mutex = furi_mutex_alloc(FuriMutexTypeNormal);
    btApp->thread = furi_thread_alloc();
    furi_thread_set_name(btApp->thread, "BtHamSender");
    furi_thread_set_stack_size(btApp->thread, 1024);
    furi_thread_set_context(btApp->thread, btApp);
    furi_thread_set_callback(btApp->thread, btApp_thread_callback);
    furi_thread_start(btApp->thread);
}

void btApp_thread_stop(BtApp* btApp) {
    furi_assert(btApp);
    FuriThreadId thread_id = furi_thread_get_id(btApp->thread);
    furi_assert(thread_id);
    furi_thread_flags_set(thread_id, BT_MOUSE_FLAG_KILL_THREAD);
    furi_thread_join(btApp->thread);
    furi_thread_free(btApp->thread);
    furi_mutex_free(btApp->mutex);
    btApp->mutex = NULL;
    btApp->thread = NULL;
}

void btApp_input_callback(InputEvent* event, void* context) {
    furi_assert(context);
    FuriMessageQueue* event_queue = context;
    furi_message_queue_put(event_queue, event, FuriWaitForever);
}

void btApp_connection_status_changed_callback(BtStatus status, void* context) {
    furi_assert(context);
    BtApp* btApp = context;
    btApp->connected = (status == BtStatusConnected);
    view_port_update(btApp->view_port);
    if(!btApp->notifications) {
        return;
    }

    if(btApp->connected) {
        notification_internal_message(btApp->notifications, &sequence_set_blue_255);
    } else {
        notification_internal_message(btApp->notifications, &sequence_reset_blue);
    }
}

void bt_start(void* context) {
    furi_assert(context);
    BtApp* btApp = context;

    btApp->bt = furi_record_open(RECORD_BT);
    bt_disconnect(btApp->bt);
    furi_delay_ms(200);
    bt_keys_storage_set_storage_path(btApp->bt, APP_DATA_PATH(HID_BT_KEYS_STORAGE_NAME));

    btApp->notifications = furi_record_open(RECORD_NOTIFICATION);
    bt_set_status_changed_callback(btApp->bt, btApp_connection_status_changed_callback, btApp);
    btApp->hid = bt_profile_start(btApp->bt, ble_profile_hid, (void*)&ble_hid_params);
    furi_hal_bt_start_advertising();

    btApp_thread_start(btApp);
}

void bt_stop(void* context) {
    furi_assert(context);
    BtApp* btApp = context;

    btApp_thread_stop(btApp);
    notification_internal_message(btApp->notifications, &sequence_reset_blue);
    bt_set_status_changed_callback(btApp->bt, NULL, NULL);
    bt_disconnect(btApp->bt);
    furi_delay_ms(200);
    bt_keys_storage_set_default_path(btApp->bt);
    furi_hal_bt_stop_advertising();
    bt_profile_restore_default(btApp->bt);
    furi_record_close(RECORD_NOTIFICATION);
    btApp->notifications = NULL;
    furi_record_close(RECORD_BT);
    btApp->bt = NULL;
}

int32_t bt_ham_clicker_app(void* p) {
    UNUSED(p);

    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));

    BtApp* btApp = malloc(sizeof(BtApp));
    memset(btApp, 0, sizeof(BtApp));

    Gui* gui = furi_record_open(RECORD_GUI);
    ViewPort* view_port = view_port_alloc();

    btApp->view_port = view_port;

    view_port_draw_callback_set(view_port, btApp_draw_callback, btApp);
    view_port_input_callback_set(view_port, btApp_input_callback, event_queue);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);
    bt_start(btApp);
    InputEvent event;
    while(true) {
        FuriStatus event_status = furi_message_queue_get(event_queue, &event, 50);

        if(event_status == FuriStatusOk) {
            if(event.key == InputKeyBack) {
                break;
            }
            if(event.type != InputTypeRelease) {
                continue;
            }

            switch(event.key) {
            case InputKeyUp:
                btApp_move(btApp, 0, -MOUSE_MOVE);
                break;

            case InputKeyDown:
                btApp_move(btApp, 0, MOUSE_MOVE);
                break;

            case InputKeyOk:
                btApp->clicking = !btApp->clicking;
                view_port_update(btApp->view_port);
                break;

            case InputKeyRight:
                btApp_move(btApp, MOUSE_MOVE, 0);
                break;

            case InputKeyLeft:
                btApp_move(btApp, -MOUSE_MOVE, 0);
                break;

            default:
                break;
            }
        }

        if(btApp->clicking) {
            btApp_button(btApp, HID_MOUSE_BTN_LEFT);
            furi_delay_ms(CLICK_DELAY);
        }
    }

    bt_stop(btApp);
    gui_remove_view_port(gui, view_port);
    view_port_free(view_port);
    return 0;
}